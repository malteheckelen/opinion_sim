.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>% print() # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>% print()
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ] %>%
unique() %>%
.[ , past_messages := sapply(past_messages, function(x) list(eval(parse(text = x))))] %>%
.[ , past_opinions := sapply(past_opinions, function(x) list(eval(parse(text = x))))] %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>%
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ] %>%
unique() %>%
.[ , past_messages := sapply(past_messages, function(x) list(eval(parse(text = x))))] %>%
.[ , past_opinions := sapply(past_opinions, function(x) list(eval(parse(text = x))))] %>% print()
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>%
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ]
copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>%
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ] %>%
unique()
wowee <- copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>%
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ] %>%
unique()
wowee
wowee <- copy(sim$actions_send[ , -c("util_score")]) %>%
.[copy(prepre_messi), on = c("agent_id" = "from"), allow.cartesian = TRUE] %>%
setnames("agent_id", "from") %>%
setkey("from") %>%
.[ actions==best_action | is.na(actions) ] %>%
.[ , -c("actions")] %>% # we need best_action further down
unique() %>%  # do something about business
.[ , sender_business := .N, by = "from" ] %>% # generate business
.[ , sender_business := ifelse(best_action == "Optimized", sender_business*2, sender_business) ] %>% # generate business
.[ , receiver_business := .N, by = "to" ] %>%  # generate business
merge(prepre_fuck_me[ , -c("sender_business", "receiver_business", "assumption_to")], by=c("from", "to"), all.x=TRUE) %>%  # get full row count back, following two lines resolve variable name conflicts
.[ , sender_business := ifelse(is.na(sender_business), 0, sender_business) ] %>% # generate business
.[ , receiver_business := ifelse(is.na(receiver_business), 0, receiver_business) ] %>%  # generate business
#.[ , past_opinions := ifelse(!is.na(past_opinions.y) & sapply(past_opinions.y, is.numeric), past_opinions.y, past_opinions.x)] %>%
#.[ , -c("past_opinions.x", "past_opinions.y")] %>%
.[ , past_messages := ifelse(lengths(past_messages) < params(sim)$rc_energy_model$message_memory_depth,
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_messages, y=opt_message)),
ifelse(.[ , best_action] == "Unoptimized",
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$message_memory_depth], y))
}, x=past_messages, y=opt_message)
)
)] %>%
.[ , past_opinions := ifelse(lengths(past_opinions) < params(sim)$rc_energy_model$opinion_memory_depth,
mapply(function(x, y) {
list(c(unlist(x), y))
}, x=past_opinions, y=opinion_from),
mapply(function(x, y) {
list(c(unlist(x)[1:params(sim)$rc_energy_model$opinion_memory_depth], y))
}, x=past_opinions, y=opinion_from)
)
] %>%
.[ , distance_to_past_opinions := mapply(function(a,b) {
mean(
sapply(a, function(x) {
abs(x - b)
})
)
}, a=past_opinions, b=assumption_to)] %>%
setnames("opinion_from", "opinion") %>%
setnames("opt_message", "message") %>%
.[ , .(from, to, opinion, message, past_messages, past_opinions, distance_to_past_opinions, sender_business, receiver_business, past_sender_business, past_receiver_business, past_nbh_incohesion, past_self_incohesion)] %>%
.[copy(sim$messages[ , -c("opt_message", "assumption_to", "opinion_from")]), on = c("from", "to"), nomatch = 0L, allow.cartesian = TRUE] %>%
.[ , past_messages := as.character(past_messages) ] %>%
.[ , past_opinions := as.character(past_opinions) ] %>%
.[ , past_receiver_business := as.character(past_messages) ] %>%
.[ , past_sender_business := as.character(past_opinions) ]
wowee[ , 12]
fuck_me
ifelse(nrow(sim$discourse_memory)<480, print(paste("It's time: ", time(sim))), print("not yet"))
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
times <- list(start = 0, end = 20)
parameters <- list(
basic_setup = list(
opinion_distribution = "uniform",
no_agents = 30
),
small_world = list(
dim = 1,
rewire_p = 0.6
),
rc_energy_model = list(
epsilon = 0.15,
other_incons_tolerance = 0.6,
self_incons_tolerance = 0.6,
opinion_memory_depth = 10,
energy_level = 10,
message_memory_depth = 10,
energy_params_memory_depth = 10
)
)
paths <- getPaths()
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
out$data_collect %>%
as_tibble() %>%
ggplot(aes(time, opinions)) +
geom_point(size= 0.02, alpha=0.2, colour="dodgerblue3") +
theme_bw()
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
times <- list(start = 0, end = 50)
parameters <- list(
basic_setup = list(
opinion_distribution = "uniform",
no_agents = 80
),
small_world = list(
dim = 1,
rewire_p = 0.6
),
rc_energy_model = list(
epsilon = 0.15,
other_incons_tolerance = 0.6,
self_incons_tolerance = 0.6,
opinion_memory_depth = 10,
energy_level = 10,
message_memory_depth = 10,
energy_params_memory_depth = 10
)
)
paths <- getPaths()
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
out$data_collect %>%
as_tibble() %>%
ggplot(aes(time, opinions)) +
geom_point(size= 0.02, alpha=0.2, colour="dodgerblue3") +
theme_bw()
out$discourse_memory
out$discourse_memory$past_messages[1]
times <- list(start = 0, end = 50)
parameters <- list(
basic_setup = list(
opinion_distribution = "uniform",
no_agents = 80
),
small_world = list(
dim = 1,
rewire_p = 0.6
),
rc_energy_model = list(
epsilon = 0.15,
other_incons_tolerance = 0.6,
self_incons_tolerance = 0.6,
opinion_memory_depth = 10,
#energy_level = 10,
message_memory_depth = 10,
energy_params_memory_depth = 10
)
)
paths <- getPaths()
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
sim <- simInit(times = times, params = parameters, modules = modules, paths = paths)
set.seed(1234)
#profvis({
out <- spades(sim)
out$data_collect %>%
as_tibble() %>%
ggplot(aes(time, opinions)) +
geom_point(size= 0.02, alpha=0.2, colour="dodgerblue3") +
theme_bw()
out$discourse_memory
